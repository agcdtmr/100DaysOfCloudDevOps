## Days Challenges

Phase 1: Foundations

Day 1: Introduction & Motivation
	•	Theory: Goals of the challenge, Cloud & DevOps overview.
	•	Hands-On: Set personal learning & certification goals.
	•	Coding: N/A (Introduction).

Day 2: Fundamentals of Cloud Computing & DevOps
	•	Theory: Cloud computing models, DevOps lifecycle, CI/CD overview.
	•	Hands-On: Set up free-tier accounts (AWS, Azure, GCP). Launch a VM.
	•	Coding: Python script using cloud APIs (AWS Boto3).

Day 3: Linux Basics
	•	Theory: Linux command-line basics, directory structure, permissions.
	•	Hands-On: Navigate file system, manage permissions (chmod, chown).
	•	Coding: Write commonly used Linux commands for DevOps.

Day 4: Linux Advanced - Process Management & Storage Optimization
	•	Theory: Process management, shell scripting, environment variables.
	•	Hands-On: Monitor processes (ps, top).
	•	Coding: Write a script to monitor CPU usage and send alerts.

Day 5: Editors & IDEs
	•	Theory: Vim, Nano, VS Code, IDE setups.
	•	Hands-On: Install and configure preferred editors.
	•	Coding: Write a simple script using different editors.

Day 6: Automate Tasks with Bash Scripting
	•	Theory: Bash scripting fundamentals (loops, functions).
	•	Hands-On: Automate directory creation and file management.
	•	Coding: Script to automate software installations.

Day 7: PowerShell Basics
	•	Theory: Introduction to PowerShell.
	•	Hands-On: Retrieve system info (Get-Process, Get-Service).
	•	Coding: Script to create users and set permissions.

Day 8: Networking Essentials
	•	Theory: IP addresses, subnets, routing, DNS, protocols.
	•	Hands-On: Troubleshoot connectivity (ping, nslookup, traceroute).
	•	Coding: Python script to ping a list of servers.

Phase 2: Version Control & CI/CD

Day 9: Git Basics & Advanced Git
	•	Theory: Git repositories, branches, commits, workflows, rebasing.
	•	Hands-On: Create a Git repository, practice merging & resolving conflicts.
	•	Coding: Automate Git operations with scripts.

Day 10: Jenkins - CI/CD Basics
	•	Theory: Introduction to Jenkins, CI/CD concepts.
	•	Hands-On: Set up Jenkins on a local/cloud VM.
	•	Coding: Create a basic Jenkins pipeline.

Day 11: Just Enough Groovy for Jenkins Pipelines
	•	Theory: Learn Groovy scripting for Jenkins pipelines.
	•	Hands-On: Implement scripted pipelines.
	•	Coding: Create a Jenkinsfile using Groovy.

Day 12: Jenkins - Building an Agent
	•	Theory: How Jenkins agents work.
	•	Hands-On: Set up a Jenkins agent.
	•	Coding: Automate agent provisioning with scripts.

Phase 3: Cloud, Security & Web Technologies

Day 13: Cloud Networking
	•	Theory: VPCs, subnets, route tables, security groups, VPNs.
	•	Hands-On: Set up a VPC with subnets in AWS/Azure.
	•	Coding: Write Terraform code to provision a VPC.

Day 14: Security Essentials
	•	Theory: SSH, SSL/TLS, firewalls, access control lists.
	•	Hands-On: Secure a cloud VM with SSH keys & firewall rules.
	•	Coding: Automate firewall rule configuration.

Day 15: Web Servers & Proxy Concepts
	•	Theory: Nginx, Apache, reverse proxy, load balancing, caching.
	•	Hands-On: Deploy a web server.
	•	Coding: Write an Nginx configuration file.

Day 16: Databases & SQL
	•	Theory: RDBMS (AWS RDS, Azure SQL), indexing, backups.
	•	Hands-On: Deploy a cloud-based database instance.
	•	Coding: Write SQL queries and backup automation.

Phase 4: Configuration Management & Infrastructure as Code

Day 17: Configuration Management - Ansible
	•	Theory: Ansible fundamentals.
	•	Hands-On: Install Ansible, create a simple playbook.
	•	Coding: Automate web server setup with Ansible.

Day 18: Configuration Management - Chef
	•	Theory: Introduction to Chef.
	•	Hands-On: Install and configure Chef.
	•	Coding: Write a Chef recipe for package installations.

Day 19: Configuration Management - Puppet
	•	Theory: Introduction to Puppet.
	•	Hands-On: Install and configure Puppet.
	•	Coding: Write a Puppet manifest to configure a server.

Day 20: Infrastructure as Code (IaC) with Terraform
	•	Theory: Terraform basics, Infrastructure as Code (IaC). Understanding Infrastructure as Code (Terraform vs. CloudFormation vs. Pulumi).
	•	Hands-On: Install Terraform and create a basic AWS/GCP/Azure infrastructure using Terraform.

Phase 5: Kubernetes & Cloud-Native Technologies

Day 21: Kubernetes Basics
	•	Theory: Kubernetes architecture (pods, nodes, clusters).
	•	Hands-On: Set up Minikube and run a cluster.
	•	Coding: Deploy an app using kubectl.

Day 22: Kubernetes Deployments
	•	Theory: Deployments, ReplicaSets.
	•	Hands-On: Deploy a Kubernetes Pod.
	•	Coding: Write a YAML file for deployment.

Day 23: Kubernetes Services & Networking
	•	Theory: ClusterIP, NodePort, LoadBalancer.
	•	Hands-On: Expose a Kubernetes service.
	•	Coding: Create a multi-tier Kubernetes Service YAML file.

Day 24: Helm Package Manager
	•	Theory: Introduction to Helm.
	•	Hands-On: Install Helm and deploy apps.
	•	Coding: Write a custom Helm chart.

Day 25: Kubernetes ConfigMaps & Secrets
	•	Theory: ConfigMaps and Secrets.
	•	Hands-On: Use ConfigMaps and Secrets.
	•	Coding: Automate ConfigMaps and Secrets creation.

Day 26: Kubernetes Namespaces & Resource Management
	•	Theory: Namespaces, Resource Requests, Limits.
	•	Hands-On: Set up a multi-namespace cluster.
	•	Coding: Write YAML files for resource requests & limits.

Phase 6: Advanced Concepts & DevSecOps

Day 27: GitOps with FluxCD
	•	Theory: What is GitOps? FluxCD benefits.
	•	Hands-On: Set up FluxCD in a Kubernetes cluster.
	•	Coding: Create a GitOps pipeline to deploy an app.

Day 28: Service Mesh Concepts (Istio, Linkerd)
	•	Theory: What is a Service Mesh? Introduction to Istio & Linkerd.
	•	Hands-On: Install Istio or Linkerd on Kubernetes.
	•	Coding: Set up traffic routing & retries with Istio/Linkerd.

Day 29: Kubernetes Security & RBAC
	•	Theory: Kubernetes security concepts (RBAC, Network Policies).
	•	Hands-On: Implement Role-Based Access Control (RBAC) in Kubernetes.
	•	Coding: Write YAML files to create RBAC roles and bindings.

Day 30: Cloud-Native Security & DevSecOps
	•	Theory: Security in cloud-native environments, DevSecOps principles.
	•	Hands-On: Install Trivy or Aqua Security for container scanning.
	•	Coding: Write a script to scan Docker images for vulnerabilities.

🔹 Phase 7: Advanced Infrastructure & Automation (Day 31-40)

Day 31: Cloud Compute & Serverless
	•	Theory: EC2 vs. Fargate vs. Lambda vs. Cloud Run.
	•	Hands-On: Deploy a function in AWS Lambda or GCP Cloud Run.
	•	Coding: Automate serverless deployment with Terraform.

Day 32: Terraform Advanced - State, Workspaces & Modules
	•	Theory: Remote state, backend storage, Terraform Cloud.
	•	Hands-On: Store Terraform state in AWS S3 with state locking.
	•	Coding: Write reusable Terraform modules.

Day 33: Terraform & CI/CD Automation
	•	Theory: Terraform with Jenkins, GitHub Actions, GitLab CI.
	•	Hands-On: Create a GitOps workflow for Terraform.
	•	Coding: Write a GitHub Actions pipeline to deploy Terraform infrastructure.

Day 34: AWS CloudFormation & AWS CDK
	•	Theory: AWS CloudFormation vs. Terraform vs. CDK.
	•	Hands-On: Deploy infrastructure using CloudFormation & AWS CDK.
	•	Coding: Write an AWS CDK script in Python.

Day 35: Ansible Advanced - Scaling & Vault Integration
	•	Theory: Dynamic inventories, encrypted secrets with Vault.
	•	Hands-On: Automate multi-server provisioning using Ansible.
	•	Coding: Write an Ansible playbook with dynamic AWS inventory.

🔹 Phase 8: DevOps Automation & CI/CD Pipelines (Day 36-50)

Day 36: CI/CD with Jenkins on Kubernetes
	•	Theory: Jenkins on Kubernetes, auto-scaling Jenkins agents.
	•	Hands-On: Deploy Jenkins using Helm in Kubernetes.
	•	Coding: Write a Jenkins pipeline that builds & deploys a Kubernetes app.

Day 37: CI/CD with GitHub Actions & GitLab CI
	•	Theory: GitHub Actions vs. GitLab CI vs. Jenkins.
	•	Hands-On: Automate build & deployment using GitHub Actions.
	•	Coding: Write a GitHub Actions workflow for CI/CD.

Day 38: CI/CD with ArgoCD for Kubernetes GitOps
	•	Theory: ArgoCD, FluxCD, GitOps principles.
	•	Hands-On: Deploy an application using ArgoCD.
	•	Coding: Automate app deployment via GitOps.

Day 39: Container Security & DevSecOps Pipeline
	•	Theory: SAST, DAST, Image Scanning, SBOM.
	•	Hands-On: Scan Docker images with Trivy or Aqua Security.
	•	Coding: Integrate security scanning in a Jenkins pipeline.

Day 40: Canary & Blue-Green Deployments in Kubernetes
	•	Theory: Progressive delivery strategies.
	•	Hands-On: Implement a canary deployment using Istio or Argo Rollouts.
	•	Coding: Write a Kubernetes deployment strategy.

🔹 Phase 9: Cloud Networking, Load Balancing & Security (Day 41-55)

Day 41: Cloud Networking Deep Dive
	•	Theory: VPC Peering, Transit Gateway, Service Mesh.
	•	Hands-On: Implement VPC Peering in AWS/GCP.
	•	Coding: Automate networking setup with Terraform.

Day 42: Load Balancers & API Gateway
	•	Theory: ALB, NLB, API Gateway, Traffic Routing.
	•	Hands-On: Deploy an API Gateway for a microservice.
	•	Coding: Configure ALB with Terraform.

Day 43: Identity & Access Management (IAM) Best Practices
	•	Theory: IAM roles, policies, least privilege.
	•	Hands-On: Secure AWS IAM roles & automate IAM setup.
	•	Coding: Write IAM policy automation scripts.

Day 44: Kubernetes Network Security
	•	Theory: Network Policies, Istio Security.
	•	Hands-On: Implement Kubernetes Network Policies.
	•	Coding: Automate security rule enforcement.

Day 45: AWS Secrets Manager & HashiCorp Vault
	•	Theory: Secret management in Cloud & DevOps.
	•	Hands-On: Store & retrieve secrets from Vault.
	•	Coding: Integrate secrets management into CI/CD.

Day 46: Web Application Firewall (WAF) & DDoS Protection
	•	Theory: AWS WAF, Cloudflare, ModSecurity.
	•	Hands-On: Configure WAF for an application.
	•	Coding: Automate security rule updates.

Day 47: Zero Trust Security & Service Mesh Authentication
	•	Theory: BeyondCorp, Istio JWT, mTLS.
	•	Hands-On: Secure microservices using Istio.
	•	Coding: Configure mutual TLS (mTLS) authentication.

Day 48: Cloud Compliance & Auditing
	•	Theory: SOC 2, HIPAA, GDPR compliance.
	•	Hands-On: Enable AWS CloudTrail or GCP Audit Logs.
	•	Coding: Write automation for compliance monitoring.

🔹 Phase 10: Observability & Performance Monitoring (Day 56-70)

Day 49: Centralized Logging with ELK / Loki
	•	Theory: Log aggregation, structured logging.
	•	Hands-On: Deploy ELK (Elasticsearch, Logstash, Kibana).
	•	Coding: Automate log ingestion & visualization.

Day 50: Monitoring with Prometheus & Grafana
	•	Theory: Metrics, alerts, PromQL.
	•	Hands-On: Deploy Prometheus & Grafana.
	•	Coding: Write custom Prometheus queries.

Day 51: Distributed Tracing with OpenTelemetry
	•	Theory: Tracing vs. Logging, OpenTelemetry.
	•	Hands-On: Set up tracing in a microservices app.
	•	Coding: Instrument an application with OpenTelemetry.

Day 52-55: Site Reliability Engineering (SRE) Principles
	•	Concepts: SLIs, SLOs, Error Budgets, Incident Response.
	•	Hands-On: Define SLIs/SLOs & create dashboards.
	•	Coding: Automate alerts based on error budgets.

🔹 Phase 11: Advanced Kubernetes & Cloud-Native Architectures (Day 71-85)

Day 56-60: Multi-Cluster Kubernetes & Edge Computing
	•	Topics: Multi-cluster networking, K3s, Kubernetes at the Edge.
	•	Hands-On: Deploy a multi-cluster architecture.
	•	Coding: Automate deployment across clusters.

Day 61-65: Serverless DevOps with AWS Lambda, GCP Cloud Run
	•	Topics: Serverless patterns, async processing.
	•	Hands-On: Deploy a serverless microservice.
	•	Coding: Automate serverless deployments.

Day 66-70: FinOps & Cloud Cost Optimization
	•	Topics: AWS Cost Explorer, Reserved Instances, Kubernetes Cost Management.
	•	Hands-On: Analyze cloud spend & optimize costs.
	•	Coding: Automate cost reporting.

🔹 Phase 12: Final Projects & Capstone (Day 86-100)

Day 71-85: Real-World Capstone Projects
	•	Project 1: Build a CI/CD pipeline for microservices in Kubernetes.
	•	Project 2: Deploy a full DevOps toolchain on AWS/GCP.
	•	Project 3: Secure an application with DevSecOps & Zero Trust.

Day 86-100: Interview Prep & Certifications
	•	AWS/GCP/Azure DevOps Certifications
	•	Kubernetes CKA/CKS/CKAD Exam Prep
	•	Mock Interviews & Whiteboard Challenges


### Bonus

1. DevOps Culture & Soft Skills
	•	Theory: DevOps culture, collaboration, communication, and continuous improvement.
	•	Hands-On: Work in cross-functional teams, perform post-mortem analyses, and practice empathy with development and operations teams.
	•	Coding: Incorporate tools like Slack and Jira with automation to enhance communication between teams.

2. Cloud Cost Optimization & FinOps (Beyond AWS)
	•	Theory: In-depth FinOps strategies, cost modeling, and optimization for cloud workloads.
	•	Hands-On: Use tools like CloudHealth, CloudCheckr, or Google Cloud’s cost management tools to implement cost-saving measures.
	•	Coding: Automate cloud cost monitoring and alerting through APIs (AWS Cost Explorer, GCP’s Billing API, etc.).

3. Chaos Engineering
	•	Theory: Introduction to Chaos Engineering and its role in improving system reliability.
	•	Hands-On: Set up Chaos Engineering experiments using tools like Gremlin or Chaos Monkey in a cloud-native environment.
	•	Coding: Write scripts to introduce chaos (e.g., kill processes, introduce latency) and measure the system’s resilience.

4. Advanced Security Practices in Cloud-Native Environments
	•	Theory: Deeper focus on securing cloud-native applications, including vulnerability scanning and securing pipelines.
	•	Hands-On: Set up advanced security tools such as Falco, Aqua Security, or Sysdig for runtime protection.
	•	Coding: Create policies that enforce security standards across cloud-native applications using OPA (Open Policy Agent) and implement security checks in CI/CD.

5. Compliance as Code & Auditing
	•	Theory: The importance of compliance in cloud-native environments and “Compliance as Code.”
	•	Hands-On: Use HashiCorp Sentinel, OPA, or Kubernetes Security Contexts to enforce compliance standards like GDPR, HIPAA, or PCI-DSS.
	•	Coding: Automate audits and compliance reporting with code (e.g., create reports on compliance state).

6. Serverless Event-Driven Architectures
	•	Theory: Deep dive into event-driven architectures (EDA) and serverless computing (FaaS).
	•	Hands-On: Build a serverless event-driven application using AWS Lambda, Google Cloud Functions, or Azure Functions, and link it to services like AWS SQS, SNS, or EventBridge.
	•	Coding: Write a serverless backend for event-driven processing, including triggers and actions.

7. Immutable Infrastructure & Containerization Best Practices
	•	Theory: Immutable infrastructure principles in a cloud-native environment.
	•	Hands-On: Deploy containers that adhere to immutable principles, leveraging Kubernetes and Docker.
	•	Coding: Automate container deployments with Helm charts that enforce immutability in production environments.

8. Kubernetes Operators for Custom Automation
	•	Theory: Learn about Kubernetes Operators, custom controllers, and CRDs (Custom Resource Definitions).
	•	Hands-On: Build and deploy a simple Kubernetes Operator to automate tasks within your Kubernetes cluster (e.g., managing databases or custom resources).
	•	Coding: Develop a custom Kubernetes Operator using the Operator SDK or Kopf in Python.

9. Multi-Region & Multi-Cloud Failover Strategies
	•	Theory: Best practices for multi-region or multi-cloud deployments for disaster recovery and high availability.
	•	Hands-On: Set up multi-region Kubernetes clusters across AWS, GCP, or Azure.
	•	Coding: Automate failover and backup strategies using Terraform or cloud-native infrastructure-as-code tools.

10. Cloud-Native Machine Learning (MLOps)
	•	Theory: MLOps best practices and the role of DevOps in machine learning.
	•	Hands-On: Deploy ML models in production using Kubernetes and tools like Kubeflow or MLflow.
	•	Coding: Write code to automate the lifecycle of machine learning models, from training to deployment, including integration with CI/CD pipelines.

11. Data Pipelines in the Cloud
	•	Theory: Introduction to building and managing data pipelines in the cloud for real-time analytics and machine learning.
	•	Hands-On: Implement a basic data pipeline using tools like Apache Kafka, Apache Airflow, or AWS Glue.
	•	Coding: Create scripts to automate data ingestion, transformation, and movement across cloud environments.

12. Event-Driven CI/CD
	•	Theory: Moving towards event-driven CI/CD pipelines.
	•	Hands-On: Set up event-based triggers for CI/CD pipelines using GitHub Actions, Tekton, or Spinnaker.
	•	Coding: Create custom event-driven workflows for CI/CD pipelines that automatically trigger on code changes or infrastructure updates.

Additional Tools & Technologies to Consider:
	1.	HashiCorp Vault for secrets management.
	2.	Argo Rollouts for progressive delivery.
	3.	DynamoDB, CosmosDB for NoSQL database operations.
	4.	HashiCorp Consul for service discovery and mesh management.
	5.	AWS CloudFormation or Terraform to create Infrastructure as Code (IaC) for cloud deployments.
	6.	Prometheus & Grafana for cloud-native monitoring (in addition to Datadog).
	7.	Kong API Gateway for managing APIs across cloud environments.
	8.	AIOps for cloud monitoring and predictive scaling.

Integrating soft skills, advanced security practices, and multi-cloud strategies will give us an edge, and diving deeper into emerging trends like MLOps and chaos engineering will keep your skill set current and cutting-edge.

Happy learning! You’re on track to becoming a complete Cloud DevOps professional by the end of Day 100!
